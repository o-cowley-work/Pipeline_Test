@Library('Scoped_Library') _ 


import groovy.transform.Field

import Pipeline_Test.Additional.StaticInfo


// @Field def supportedProjects = []
// @Field def supportedPlatforms = []
// @Field def supportedRings = []



node{
    checkoutFromGit()

    runPipeline()

}


def checkoutFromGit() {
    stage("Clone the build to use") {
        checkout (poll: false, 
            scm: [$class: 'GitSCM', 
            branches: [[name: '*/main']], 
            extensions: [[$class: 'CleanBeforeCheckout']], 
            userRemoteConfigs: [[credentialsId: '6859c06b-0809-4875-b655-28d3d5d4b152', 
                                url: 'https://github.com/oliverIwork/Pipeline_Test.git']]]
        )
    }
    
}


def runPipeline() {
    stage("Check if things are there") {
        echo "The current directory from env variable is: $env.WORKSPACE"
        
        def work = pwd()
        echo "This is the current director from pwd(): $work"

        echo "Testing a load of the script lib"
        def script_loaded = load ("$work/Additional/additional_scripts.groovy")

        script_loaded.doStuff("OOOOOOLIVER")

    }

    stage("Testing a class import") {
        
        echo "$StaticInfoA.TEST_WORDS"
    }
    
    
	
}

// def runParallelTest() {
//     Map toRun = [:]

//     toRun["Outer A"] = {
//         echo "I'm about to start a parallel block"
//         runParallel()
//         }
//     toRun["Outer B"] = {
//         echo "I'm not a parallel block"

//         }

//     parallel(toRun)
// }

// def fillVariables() {
//     stage("test filling variables") {
//         supportedProjects = test_var.get_supported_projects()
//         supportedPlatforms = test_var.get_supported_platforms()
//         supportedRings = test_var.get_supported_rings()
//     }
    
// }

// def libResourceGrab() {
//     stage ("test resource grab") {
//         script {
//             test_var.return_library_resource()
//         }
        
//     }
    
// }


// def runParallel() {
//     Map toRun = [:]

//     toRun["StepA"] = {node ("Windows_Node") {echo "Doing A"}}
//     toRun["StebB"] = {node ("built-in") {echo "Doing B"}}

//     return parallel(toRun)
// }